str(b)
b <- data.frame(a, col.names = c("GridID", "Wert", "Rate"))
a = array(1:9, c(3,3))
b <- data.frame(a, col.names = c("GridID", "Wert", "Rate"))
str(b)
b <- as.data.frame(a, col.names = c("GridID", "Wert", "Rate"))
str(b)
b <- as.data.frame(a, col.names = names("GridID", "Wert", "Rate"))
str(b)
b <- as.data.frame(a, names = c("GridID", "Wert", "Rate"))
str(b)
a = array(1:12, c(4,3))
b <- as.data.frame(a)
names(b) = c("GridID", "MU_GLOBAL", "Rate")
str(b)
#' High resolution data reclassfy to low resolution data: N*N data to 1 data, and in the table(ID, Code, )
#' @importFrom utils read.table
#' @param filePath filename grid-data aus ArcGIS, there are 6 row ist meta data
#' @param classifyN intger how many data to 1 data
#' @param GridID 2-array, the gridID in geological
#' @param leftDropN how many grid in left in High resolution data would deleate
#' @param upDropN how many grid in up in High resolution data would deleate
#' @return a new data mit low resolution data
#' @export
fctClassify <- function(OriginalWert, GridID, classifyN, leftDropN = 0, upDropN = 0){
infoGridRowN = dim(GridID)[1]  #the rows number of FLOWDRIC
infoGridColN = dim(GridID)[2]   #the clows number of FLOWDRIC
if(leftDropN != 0) OriginalWert <- OriginalWert[, -(1:leftDropN)]
if(upDropN != 0) OriginalWert <- OriginalWert[-(1:upDropN),]
TableWert = array(valueNoData,c(1,3))
for (i in 1:infoGridColN) {
for (j in 1:infoGridRowN) {
if(!is.na(GridID[j,i])){
LanduseTem = as.matrix(OriginalWert[(1 + (j - 1) * classifyN):(j * classifyN),
(1 + (i - 1) * classifyN):(i * classifyN)])
LanduseArtTem = table(unlist(LanduseTem))
lengthTem = length(LanduseArtTem)
MatrixTem = array(GridID[j,i], c(lengthTem,3))
MatrixTem[,2] = as.integer(dimnames(LanduseArtTem)[[1]])
RateTem = as.integer(LanduseArtTem)
rateTem2 = sum(RateTem)
MatrixTem[,3] = RateTem / rateTem2
TableWert = rbind(TableWert,MatrixTem)
}
else next
}
}
TableWert <- TableWert[-1,]
TableWert <- as.data.frame(TableWert)
names(TableWert) = c("GridID", "Wert", "Rate")
return(TableWert)
}
#' read grid-data from ArcGIS
#' @importFrom utils read.table
#' @param filePath filename grid-data aus ArcGIS, there are 6 row ist meta data
#' @param classifyN intger how many data to 1 data
#' @param GridID 2-array, the gridID in geological
#' @param leftDropN how many grid in left in High resolution data would deleate
#' @param upDropN how many grid in up in High resolution data would deleate
#' @return a new data mit low resolution data
#' @export
read.grid <- function(filePath, ...){
MetaData = read.table(filePath, nrows = 6)
NODATA_value = MetaData[6,2]
GridWert = read.table(filePath, skip = 6, na.strings = valueNoData)
for (i in 1:6) attr(GridWert, as.character(MetaData[i,1])) = MetaData[i,2]
return(GridWert)
}
ow <- read.grid(filePath)
fy <- fctClassify(ow, GridID, 20, 0, 5)
str(fy)
gid <- read.grid(filePathGridID)
fy <- fctClassify(ow, GridID, 20, 0, 5)
str(fy)
gid
View(fy)
fy <- fctClassify(ow, gid, 20, 0, 5)
str(fy)
str(gid)
###### read Grid Info include river, estuary, hydrostation infomation ######
GridID <- read.grid(filePathGridID)
infoGridRowN
infoGridRowN = attr(GridID, "nrows")  #the rows number of FLOWDRIC
infoGridColN = attr(GridID, "ncols")   #the clows number of FLOWDRIC
infoGridN
GridAllIDVector = array(GridID,c(infoGridRowN * infoGridColN))
infoGridN <- length(GridAllIDVector[!is.na(GridAllIDVector)])
infoGridN
View(GridID)
str(GridAllIDVector)
str(GridID)
infoGridN <- length(GridID[!is.na(GridID)])
infoGridN
GridID[!is.na(GridID)]
GridGridID = GridID[!is.na(GridID)]
str(GridGridID)
FlowDirection <- read.grid(filePathFlowDirection)
GridDEM = fctClassify(read.grid(filePathDEM), GridID, 20, 0, 5) ##m
#####
GridLanduse = fctClassify(read.grid(filePathLanduse), GridID, 20, 0, 5)
LanduseLib = read.table(filePathLanduseLib, header = T, row.names = 1)
LAI = as.data.frame(cbind(id = LanduseLib$code, LanduseLib[,6:17]))
RoughLength = as.data.frame(cbind(id = LanduseLib$code, LanduseLib[,18:29]))
DisplaceHeight = as.data.frame(cbind(id = LanduseLib$code, LanduseLib[,30:41]))
names(FrameGridLanduse) = c("GridID", "code", "Rate")
GridLanduseParamTem = join(FrameGridLanduse, LanduseLib)[,-2]
str(LanduseLib)
infoLandusParamN
str(GridLanduseParamTem)
View(GridLanduseParamTem)
View(LanduseLib)
View(FrameGridLanduse)
str(GridLanduseParam)
dim(LanduseLib)
infoLandusParamN = dim(LanduseLib)[2]
View(GridLanduseParamTem)
str(join(GridLanduse, LanduseLib))
names(GridLanduse) = c("GridID", "code", "Rate")
str(join(GridLanduse, LanduseLib))
str(GridLanduseParamTem)
gridParamJion <- function(GridCodeTable, gridN, ParamLib){
paramN <- dim(ParamLib)[2]
names(GridCodeTable) = c("GridID", "Code", "Rate")
GridParamTem = join(GridLanduse, ParamLib)[,-2]
GridParam = array(0.0, c(gridN, paramN))
GridParam[,1] = 1:gridN
for (i in 2:paramN) {
GridParam[,i] = tapply(GridParamTem[,2] * GridParamTem[,1 + i],
GridParamTem[,1], sum)
}
colnames(GridParam) = names(ParamLib)
GridParam = as.data.frame(GridParam)
}
a = fctClassify(read.grid(filePathLanduse), GridID, 20, 0, 5)
b = read.table(filePathLanduseLib, header = T, row.names = 1)
c = gridParamJion(a, 311, b)
str(c)
str(a)
str(b)
dim(b)
GridCodeTable = a
ParamLib = b
gridN = 311
paramN <- dim(ParamLib)[2]
names(GridCodeTable) = c("GridID", "Code", "Rate")
GridParamTem = join(GridLanduse, ParamLib)[,-2]
str(GridParamTem)
str(ParamLib)
str(GridLanduse)
gridParamJion <- function(GridCodeTable, gridN, ParamLib){
paramN <- dim(ParamLib)[2]
names(GridCodeTable) = c("GridID", "Code", "Rate")
GridParamTem = join(GridCodeTable, ParamLib)[,-2]
GridParam = array(0.0, c(gridN, paramN))
GridParam[,1] = 1:gridN
for (i in 2:paramN) {
GridParam[,i] = tapply(GridParamTem[,2] * GridParamTem[,1 + i],
GridParamTem[,1], sum)
}
colnames(GridParam) = names(ParamLib)
GridParam = as.data.frame(GridParam)
}
a = fctClassify(read.grid(filePathLanduse), GridID, 20, 0, 5)
b = read.table(filePathLanduseLib, header = T, row.names = 1)
c = gridParamJion(a, 311, b)
str(c)
str(read.grid(filePathLanduse))
str(GridLanduse)
#####
GridLanduse = fctClassify(read.grid(filePathLanduse), GridID, 20, 0, 5)
LanduseLib = read.table(filePathLanduseLib, header = T, row.names = 1)
GLP = gridParamJion(GridLanduse, 311, LanduseLib)
#####
OGL = read.grid(filePathLanduse)
use_data(OGL)
LLib = read.table(filePathLanduseLib, header = T, row.names = 1)
use_data(LLib)
#' read grid-data from ArcGIS
#' @importFrom plyr join
#' @param GridCodeTable datafram mit GridID, wert, Rate. name of Wert must same with first column of ParamLib.(output from fctClassfy)
#' @param gridN intger, how many grid.
#' @param ParamLib datafram, Data set corresponding to each type.
#' @return a datafram(gridN, paramN)
#' @examples
#' GL = fctClassify(OGL, 311, 20, 0, 5)
#' GLP = gridParamJion(GL, 311, LLib)
#' @export
gridParamJion <- function(GridCodeTable, gridN, ParamLib){
if(names(GridCodeTable)[2] != names(ParamLib)[1]) stop("Name of Wert(2.col name of GridCodeTable)  must same with first name col of ParamLib.",
"\nnow is: ", names(GridCodeTable)[2], " and ", names(ParamLib)[1])
paramN <- dim(ParamLib)[2]
GridParamTem = join(GridCodeTable, ParamLib)[,-2]
GridParam = array(0.0, c(gridN, paramN))
GridParam[,1] = 1:gridN
for (i in 2:paramN) {
GridParam[,i] = tapply(GridParamTem[,2] * GridParamTem[,1 + i],
GridParamTem[,1], sum)
}
colnames(GridParam) = names(ParamLib)
GridParam = as.data.frame(GridParam)
}
###### read LanduseData ###########
GridLanduse = fctClassify(read.grid(filePathLanduse), GridID, 20, 0, 5)
names(GridLanduse) = c("GridID", "Code", "Rate")
LanduseLib = read.table(filePathLanduseLib, header = T, row.names = 1)
GridLanduseParam = gridParamJion(GridLanduse, 311, LanduseLib)
str(GridSoil)
names(GridSoil) = c("GridID", "MU_GLOBAL", "Rate")
str(GridSoil)
#' @importFrom utils read.table
#' @param OriginalWert original wert grid-data aus ArcGIS, there are 6 row ist meta data
#' @param classifyN intger how many data to 1 data
#' @param GridID 2-array, the gridID in geological
#' @param leftDropN how many grid in left in High resolution data would deleate
#' @param upDropN how many grid in up in High resolution data would deleate
#' @return a new data in datafram(crid ID, wert, rate) mit low resolution data
#' @examples
#' GL = fctClassify(OGL, 311, 20, 0, 5)
#' @export
fctClassify <- function(OriginalWert, GridID, classifyN, leftDropN = 0, upDropN = 0){
infoGridRowN = dim(GridID)[1]  #the rows number of FLOWDRIC
infoGridColN = dim(GridID)[2]   #the clows number of FLOWDRIC
if(leftDropN != 0) OriginalWert <- OriginalWert[, -(1:leftDropN)]
if(upDropN != 0) OriginalWert <- OriginalWert[-(1:upDropN),]
TableWert = array(0.0,c(1,3))
for (i in 1:infoGridColN) {
for (j in 1:infoGridRowN) {
if(!is.na(GridID[j,i])){
LanduseTem = as.matrix(OriginalWert[(1 + (j - 1) * classifyN):(j * classifyN),
(1 + (i - 1) * classifyN):(i * classifyN)])
LanduseArtTem = table(unlist(LanduseTem))
lengthTem = length(LanduseArtTem)
MatrixTem = array(GridID[j,i], c(lengthTem,3))
MatrixTem[,2] = as.integer(dimnames(LanduseArtTem)[[1]])
RateTem = as.integer(LanduseArtTem)
rateTem2 = sum(RateTem)
MatrixTem[,3] = RateTem / rateTem2
TableWert = rbind(TableWert,MatrixTem)
}
else next
}
}
TableWert <- TableWert[-1,]
TableWert <- as.data.frame(TableWert)
names(TableWert) = c("GridID", "Wert", "Rate")
return(TableWert)
}
###### read SoilData ###########
GridSoil = fctClassify(read.grid(filePathSoil), GridID, 20, 0, 5)
str(GridSoil)
###### read LanduseData ###########
GridLanduse = fctClassify(read.grid(filePathLanduse), GridID, 20, 0, 5)
names(GridLanduse) = c("GridID", "Code", "Rate")
LanduseLib = read.table(filePathLanduseLib, header = T, row.names = 1)
GridLanduseParam = gridParamJion(GridLanduse, infoGridN, LanduseLib)
###### read SoilData ###########
GridSoil = fctClassify(read.grid(filePathSoil), GridID, 20, 0, 5)
names(GridSoil) = c("GridID", "MU_GLOBAL", "Rate")
SoilMatricPotential = read.table(filePathSoilInterpolation, row.names = 1)
MU2Class = read.table(filePathMU2Class, header = T)
SoilLib = read.table(filePathSoilLib, header = T, row.names = 1)
str(MU2Class)
SoilLib = read.table(filePathSoilLib, header = T, row.names = 1)
str(SoilLib)
dim(SoilLib)[1]
infoSoilParamN = dim(SoilLib)[2]
infoSoilParamN
GridTopSoil = GridSoilClass[,c(1,4,3)]
names(GridTopSoil) = c("GridID", "Code", "Rate")
TopSoilParam = gridParamJion(GridTopSoil, infoGridN, SoilLib)
str(TopSoilParam)
GridSubSoil = GridSoilClass[,c(1,5,3)]
names(GridSubSoil) = c("GridID", "Code", "Rate")
SubSoilParam = gridParamJion(GridSubSoil, infoGridN, SoilLib)
str(SubSoilParam)
colnames(TopSoilParam) = paste("T_",names(SoilLib),sep = "")
colnames(SubSoilParam) = paste("S_",names(SoilLib),sep = "")
GridSoilParam = as.data.frame(cbind(TopSoilParam, SubSoilParam[,2:infoSoilParamN]))
GridDEM4UH
str(GridDEM_m_Matrix)
ls()
rm(ls())
rm(list = ls())
load("F:/G2/R-program/RPackge/HMtools/data/LLib.rda")
load("F:/G2/R-program/RPackge/HMtools/data/OGL.rda")
str(OGL)
library(devtools)
document()
setwd("F:\\G2\\R-program\\RPackge\\HMtools")
document()
document()
detach("package:EDHM", unload = TRUE)
document()
library(HMtools)
document()
library(HMtools)
document()
library(HMtools)
library(VectorTools)  ##Vector opretion
library(OptimizationPrg)
library(HMtools)
library(plyr)  ## join
library(openxlsx)  ## read excel
library(hydroGOF)
library(hydroTSM)
library(mcga)
library(mcga)
library(purrr)
library(EDHM)
library(lubridate)
infoStarDay = as.Date("1989-1-1") ##*##
infoEndDay = as.Date("1993-12-31") ##*##
DateDay = seq(infoStarDay,infoEndDay,1)
infoPeriodN = length(DateDay)
wdOtherData = "F:/G2/ArbeitDisHydroModell/DistributeHydrologyModell/OtherData"
filePathGridID = "ct_id5.txt"
filePathLocation = "ct_location.txt"
filePathFlowDirection = "ct_direction5.txt"
filePathRiverGridID = "ct_river_id.txt"
filePathEstuaryID = "ct_estuary_id.txt"
filePathHydroStationID = "ct_hydrostation_id.txt"
filePathDEM = "ct_dem025.txt"
filePathLanduse = "ct_landuse025.txt"
filePathLanduseLib = "landuse_lib_qinguha1ji.txt"
filePathSoil = "ct_soil025.txt"
filePathSoilInterpolation = "soil_interpolation.txt"
filePathMU2Class = "MU2Class.txt"
filePathSoilLib = "soil_lib.txt"
filePathObserve = "cuntan1979-2012.txt"
wdPathMetroData = "F:/G2/ArbeitDisHydroModell/DistributeHydrologyModell/MetroData_Cuntan"
filePathStaLocation = "StationLocation.txt"
setwd(wdOtherData)
###### read Grid Info include river, estuary, hydrostation infomation ######
GridID <- read.grid(filePathGridID)
infoGridRowN = attr(GridID, "nrows")  #the rows number of FLOWDRIC
infoGridColN = attr(GridID, "ncols")   #the clows number of FLOWDRIC
GridAllIDVector = array(GridID,c(infoGridRowN * infoGridColN))
infoGridN <- length(GridID[!is.na(GridID)])
GridGridID = GridID[!is.na(GridID)]
GridLocation = read.table(filePathLocation, header = T)
FlowDirection <- read.grid(filePathFlowDirection)
RiverGridID = read.table(filePathRiverGridID) #one demesion
EstuaryID = read.table(filePathEstuaryID) #one demesion
HydroStationID = read.table(filePathHydroStationID) #one wert
GridDEM = fctClassify(read.grid(filePathDEM), GridID, 20, 0, 5) ##m
GridEvalution = tapply(GridDEM[,2] * GridDEM[,3], GridDEM[,1], sum)  ##m
id = as.data.frame(GridAllIDVector)
names(id) = "id"
GridDEM_m_Matrix = join(id,as.data.frame(cbind(id = seq(1,infoGridN,1),GridEvalution)))
str(id)
str(GridEvalution)
GridDEM_m_Matrix = join(id,as.data.frame(cbind(id = seq(1,infoGridN,1),GridEvalution)))
str(GridAllIDVector)
GridAllIDVector = array(as.matrix(GridID),c(infoGridRowN * infoGridColN))
str(GridAllIDVector)
id = as.data.frame(GridAllIDVector)
names(id) = "id"
GridDEM_m_Matrix = join(id,as.data.frame(cbind(id = seq(1,infoGridN,1),GridEvalution)))
GridDEM4UH = array(GridDEM_m_Matrix[,2], dim = c(infoGridRowN,infoGridColN))
GridDEM4UH = array(GridDEM_m_Matrix[,2], dim = c(infoGridRowN,infoGridColN))
###### read LanduseData ###########
GridLanduse = fctClassify(read.grid(filePathLanduse), GridID, 20, 0, 5)
names(GridLanduse) = c("GridID", "Code", "Rate")
LanduseLib = read.table(filePathLanduseLib, header = T, row.names = 1)
GridLanduseParam = gridParamJion(GridLanduse, infoGridN, LanduseLib)
###### read SoilData ###########
GridSoil = fctClassify(read.grid(filePathSoil), GridID, 20, 0, 5)
SoilMatricPotential = read.table(filePathSoilInterpolation, row.names = 1)
MU2Class = read.table(filePathMU2Class, header = T)
SoilLib = read.table(filePathSoilLib, header = T, row.names = 1)
infoSoilParamN = dim(SoilLib)[2]
MU2Class[which(MU2Class[,3] == 0),3] = MU2Class[which(MU2Class[,3] == 0),2]
names(GridSoil) = c("GridID", "MU_GLOBAL", "Rate")
GridSoilClass = join(GridSoil, MU2Class)
GridTopSoil = GridSoilClass[,c(1,4,3)]
names(GridTopSoil) = c("GridID", "Code", "Rate")
TopSoilParam = gridParamJion(GridTopSoil, infoGridN, SoilLib)
GridSubSoil = GridSoilClass[,c(1,5,3)]
names(GridSubSoil) = c("GridID", "Code", "Rate")
SubSoilParam = gridParamJion(GridSubSoil, infoGridN, SoilLib)
colnames(TopSoilParam) = paste("T_",names(SoilLib),sep = "")
colnames(SubSoilParam) = paste("S_",names(SoilLib),sep = "")
GridSoilParam = as.data.frame(cbind(TopSoilParam, SubSoilParam[,2:infoSoilParamN]))
###### read observe Q in cuntan sattion ##############
ObserveQ = read.table(filePathObserve)
ObserveQ89_93 = ObserveQ[3654 : (3653+infoPeriodN),1]
########################################
###### read MetrologyData #########
setwd(wdPathMetroData)
infoMetroFieldN = 8  ##*## #c(2,6,7,8,9,10,11,13) 1.lat	2.Temp	3.Tmax	4.Tmin	5.U	6.sun	7.humi	8.Rainfall
StationLocationTable = read.table(filePathStaLocation, header = T)
StationLocation = StationLocationTable[,c(1, 5,6)]
infoStationN = length(StationLocationTable[,1])
StationData = array(0.0, c(infoPeriodN, infoStationN, infoMetroFieldN))
for (i in 1:infoStationN) {
Excel = read.xlsx(paste(StationLocationTable$id[i],".xlsx",sep = ""))[6942:(6941 + infoPeriodN),c(2,6,7,8,9,10,11,13)]
StationData[,i,]= as.matrix(Excel)
}
###### fist deal and check Geo data #########
StationDealData = StationData
which(StationDealData == -32766) ## 32744 32766 -32766 -32744
StationDealData[which(StationDealData == 32700)] = 0.4
StationDealData[which(StationDealData >= 32000)] = StationDealData[which(StationDealData >= 32000)] - 32000
StationDealData[which(StationDealData >= 31000)] = StationDealData[which(StationDealData >= 31000)] - 31000
StationDealData[which(StationDealData >= 30000)] = StationDealData[which(StationDealData >= 30000)] - 30000
StationDealData[,,c(2,3,4,5,6,8)] = StationDealData[,,c(2,3,4,5,6,8)] * 0.1
infoWindH = 10 ##*## in which high measure the Wind speed, because the geoDAta don't have the infomation, so in there input it. If the Geo data have the infomation, it is not neccessary.
GridMetroData = Station2GridIDW(StationLocation, GridLocation, StationDealData)
str(StationLocation)
str(GridLocation)
GridMetroData = Station2GridIDW(StationLocation, GridLocation, StationDealData)
#' Station-Data interpolation to Grid-Data with IDW
#' @param StationLocation n* 3(ID, Latitude, Longitude) 2-array of station
#' @param GridLocation n * 3(ID, Latitude, Longitude) 2-array of Grid
#' @param StationData 3-array(periodN, stationN, fieldN) of data from station
#' @param cacuStationN = 5 how many Station are relevant for a grid
#' @return Ntime * Nstation * Nfild 3-array of data for Grids
#' @export
Station2GridIDW <- function(StationLocation, GridLocation, StationData, cacuStationN = 5){
periodN <- dim(StationData)[1]
stationN <- length(StationLocation$ID)
fieldN <- dim(StationData)[3]
gridN <- length(GridLocation$ID)
message("gridN: ", gridN, "\nstationN: ", stationN, "\nperiodN: ", periodN, "\nfieldN: ", fieldN)
stationN2 <- dim(StationData)[2]
if(stationN != stationN2) stop("Make sure that the station data is a three-dimensional array (PeriodN, StationN, FieldN.)",
"\n  ***now StationN is: ", stationN2, " and ", stationN)
GridData <- array(0.0,dim = c(periodN, gridN, fieldN))
LengthG2STemLong <- outer(GridLocation$Longitude, StationLocation$Longitude, fctlengthtem)
LengthG2STemLati <- outer(GridLocation$Latitude, StationLocation$Latitude, fctlengthtem)
LengthG2STem <- LengthG2STemLong + LengthG2STemLati
LengthG2S <- LengthG2STem^0.5
LengthG2Ssamllst5S <- array(0.0, c(gridN, stationN))
for (i in 1:gridN) {
LengthG2Ssamllst5S[i,order(LengthG2S[i,])[1:cacuStationN]] <- LengthG2S[i,order(LengthG2S[i,])[1:cacuStationN]]
}
LengthSum <- rowSums(LengthG2Ssamllst5S)
WeightG2S5S <- array(0.0, c(gridN, stationN))
for (i in 1:gridN) {
WeightG2S5S[i,] <- LengthG2Ssamllst5S[i,] / LengthSum[i]
}
for (i in 1:fieldN) {
GridData[,,i] <- StationData[,,i] %*% t(WeightG2S5S)
}
return(GridData)
}
GridMetroData = Station2GridIDW(StationLocation, GridLocation, StationDealData)
GridMetroData[,,1] = infoWindH
### make LIst Vor #####
MetroList <- list(WindH = GridMetroData[,,1],
Tmean = GridMetroData[,,2],
Tmax = GridMetroData[,,3],
Tmin = GridMetroData[,,4],
WindSpeed = GridMetroData[,,5],
SunHour = GridMetroData[,,6],
RelativeHumidity = GridMetroData[,,7],
PrecipitationHoch = GridMetroData[,,8])
GeoList <- list(Evalution = GridEvalution,
Location = GridLocation,
SoilParam = GridSoilParam,
LanduseParam = GridLanduseParam)
TypeGridID <- list(GridGridID = GridGridID,
RiverGridID = RiverGridID,
EstuaryID = EstuaryID,
HydroStationID = HydroStationID)
GridList <- list(TypeGridID = TypeGridID,
GridID = GridID,
FlowDirection = FlowDirection,
GridDEM = GridDEM4UH)
setwd("F:\\G2\\R-program\\RPackge\\HMtools")
str(StationDealData)
SD = StationDealData[1:100,,]
SD <- StationDealData[1:100,,]
SLC <- StationLocation
GLC <- GridLocation
GID <- GridID
library(devtools)
use_data(SD, SLC, GLC, GID)
document()
detach("package:hydroTSM", unload = TRUE)
library(hydroTSM)
document()
document()
detach("package:EDHM", unload = TRUE)
document()
library(HMtools)
document()
library(HMtools)
library(devtools)
CheckOkMess
CheckOkMess
document()
library(HMtools)
CheckOkMess
BoundryString
BoundryString
viewNote
document()
# AtomMess <- "(It is a atom element, not a List)"
# CheckOkMess <- "Checked OK!\n"
# BoundryString <- "****************************************************\n"
# WaringString <- "|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|\n"
# viewNote <- "The \"VIEW\" mode returns a list of Arguments and output values(Out) for easy access to the input requirements and the output data structure.\n"
# checkNote <- paste0("If \"CHECK\" mode reports an error or errors, please correct the error or errors and run \"CHECK\" mode again.\n",
#                     "You can also view the specific structure of input Arguments through mode \"VIEW\".")
use_data(AtomMess,
CheckOkMess,
BoundryString,
WaringString,
viewNote,
checkNote, internal = T)
library(HMtools)
